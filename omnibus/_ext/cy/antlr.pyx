"""  # noqa
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)

4440645/863938    5.173    0.000   24.374    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:317(closure)
  4993206    4.551    0.000   13.223    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:361(getEpsilonTarget)
  4440646    3.578    0.000    7.626    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:114(__init__)
10004289/3007740    2.878    0.000    5.898    0.000 {built-in method builtins.hash}
  4451670    2.615    0.000    2.615    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:25(__init__)
 14442146    1.596    0.000    1.596    0.000 {built-in method builtins.isinstance}
  1394624    1.310    0.000    2.503    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:62(__eq__)
  2790697    1.190    0.000    4.100    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:124(__hash__)
  1397105    1.150    0.000    5.438    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:71(add)
  1397105    1.016    0.000    4.135    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:96(getOrAdd)
  3608771    0.936    0.000    1.443    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:152(checkNonGreedyDecision)
  1393552    0.931    0.000    3.533    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:129(__eq__)
     8577    0.876    0.000   24.974    0.003 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:300(computeStartState)
  2803257    0.815    0.000    1.112    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/SemanticContext.py:108(__hash__)
1556284/569333    0.782    0.000    0.940    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:134(__eq__)
   790613    0.593    0.000    1.532    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:119(__init__)
   790612    0.367    0.000    1.899    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:111(create)
  1394771    0.324    0.000    2.944    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:142(hashCodeForConfigSet)
   790635    0.312    0.000    0.771    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:71(calculateHashCode)
    79143    0.307    0.000    3.850    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:132(__eq__)
  1399180    0.277    0.000    2.555    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:156(<lambda>)
  1777084    0.250    0.000    0.250    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:144(__hash__)
  1821081    0.244    0.000    0.244    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:169(__hash__)
    17090    0.225    0.000    2.780    0.000 {built-in method _functools.reduce}
    17163    0.198    0.000    0.321    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:522(<genexpr>)
  1462292    0.193    0.000    6.834    0.000 {method 'get' of 'dict' objects}
     8577    0.187    0.000   34.498    0.004 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:88(match)
   790624    0.168    0.000    0.168    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:52(__init__)
    78417    0.166    0.000    0.322    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:293(getReachableTarget)
  1522265    0.162    0.000    0.162    0.000 {method 'append' of 'list' objects}

        3    0.000    0.000   34.668   11.556 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/BufferedTokenStream.py:298(fill)
       13    0.013    0.001   34.668    2.667 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/BufferedTokenStream.py:119(fetch)
     7292    0.021    0.000   34.653    0.005 /Users/spinlock/src/wrmsr/omnibus/omnibus/asts/_antlr/Python3Lexer.py:765(nextToken)
     7292    0.041    0.000   34.620    0.005 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/Lexer.py:105(nextToken)
     8577    0.187    0.000   34.498    0.004 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:88(match)
     8577    0.022    0.000   34.305    0.004 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:111(matchATN)
     8577    0.876    0.000   24.974    0.003 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:300(computeStartState)
4440645/863938    5.173    0.000   24.374    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:317(closure)
  4993206    4.551    0.000   13.223    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:361(getEpsilonTarget)
  4440646    3.578    0.000    7.626    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:114(__init__)
    16785    0.051    0.000    7.053    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:519(addDFAState)
  1462292    0.193    0.000    6.834    0.000 {method 'get' of 'dict' objects}
10004289/3007740    2.878    0.000    5.898    0.000 {built-in method builtins.hash}
  1397105    1.150    0.000    5.438    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:71(add)
  1397105    1.016    0.000    4.135    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:96(getOrAdd)
  2790697    1.190    0.000    4.100    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:124(__hash__)
    87719    0.050    0.000    3.907    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/dfa/DFAState.py:100(__eq__)
    79143    0.307    0.000    3.850    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:132(__eq__)
  1393552    0.931    0.000    3.533    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:129(__eq__)
  1394771    0.324    0.000    2.944    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:142(hashCodeForConfigSet)
    17085    0.005    0.000    2.811    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/dfa/DFAState.py:86(__hash__)
    17085    0.009    0.000    2.799    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:148(__hash__)
    17085    0.010    0.000    2.790    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:155(hashConfigs)
    17090    0.225    0.000    2.780    0.000 {built-in method _functools.reduce}
     8576    0.127    0.000    2.717    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:133(execATN)
  4451670    2.615    0.000    2.615    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:25(__init__)
  1399180    0.277    0.000    2.555    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:156(<lambda>)
  1394624    1.310    0.000    2.503    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:62(__eq__)
     8486    0.018    0.000    2.205    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:222(computeTargetState)
   790612    0.367    0.000    1.899    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:111(create)
     8486    0.092    0.000    1.696    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:255(getReachableConfigSet)
 14442146    1.596    0.000    1.596    0.000 {built-in method builtins.isinstance}
   790613    0.593    0.000    1.532    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:119(__init__)
"""
from libcpp cimport bool

import io

from ..._vendor.antlr4 import InputStream
from ..._vendor.antlr4 import Lexer
from ..._vendor.antlr4 import LexerATNSimulator
from ..._vendor.antlr4 import PredictionContext
from ..._vendor.antlr4 import Token
from ..._vendor.antlr4.atn import LexerActionExecutor
from ..._vendor.antlr4.atn import Transition
from ..._vendor.antlr4.atn.ATNConfig import ATNConfig
from ..._vendor.antlr4.atn.ATNConfig import LexerATNConfig
from ..._vendor.antlr4.atn.ATNConfigSet import ATNConfigSet
from ..._vendor.antlr4.atn.ATNState import ATNState
from ..._vendor.antlr4.atn.ATNState import DecisionState
from ..._vendor.antlr4.atn.ATNState import RuleStopState
from ..._vendor.antlr4.atn.SemanticContext import SemanticContext
from ..._vendor.antlr4.error.Errors import UnsupportedOperationException
from ..._vendor.antlr4.PredictionContext import SingletonPredictionContext
from ..._vendor.antlr4.atn.ATNConfigSet import OrderedATNConfigSet


# ATNConfigSet
cpdef object LexerATNSimulator__computeStartState(
        self: LexerATNSimulator,
        input: InputStream,
        p: ATNState,
):
    initialContext = PredictionContext.EMPTY
    configs = OrderedATNConfigSet()
    for i in range(0, len(p.transitions)):
        target = p.transitions[i].target
        c = LexerATNConfig(state=target, alt=i + 1, context=initialContext)
        LexerATNSimulator__closure(self, input, c, configs, False, False, False)
    return configs


# Since the alternatives within any lexer decision are ordered by
# preference, this method stops pursuing the closure as soon as an accept
# state is reached. After the first accept state is reached by depth-first
# search from {@code config}, all other (potentially reachable) states for
# this rule would have a lower priority.
#
# @return {@code true} if an accept state is reached, otherwise
# {@code false}.
cpdef bool LexerATNSimulator__closure(
        self: LexerATNSimulator,
        input: InputStream,
        config: LexerATNConfig,
        configs: ATNConfigSet,
        currentAltReachedAcceptState: bool,
        speculative: bool,
        treatEofAsEpsilon: bool
):
    if LexerATNSimulator.debug:
        print("closure(" + str(config) + ")")

    if isinstance(config.state, RuleStopState):
        if LexerATNSimulator.debug:
            if self.recog is not None:
                print("closure at", self.recog.symbolicNames[config.state.ruleIndex], "rule stop", str(config))
            else:
                print("closure at rule stop", str(config))

        if config.context is None or config.context.hasEmptyPath():
            if config.context is None or config.context.isEmpty():
                configs.add(config)
                return True

            else:
                configs.add(LexerATNConfig(
                    state=config.state,
                    config=config,
                    context=PredictionContext.EMPTY,
                ))
                currentAltReachedAcceptState = True

        if config.context is not None and not config.context.isEmpty():
            for i in range(0, len(config.context)):
                if config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE:
                    newContext = config.context.getParent(i)  # "pop" return state
                    returnState = self.atn.states[config.context.getReturnState(i)]

                    c = LexerATNConfig(
                        state=returnState,
                        config=config,
                        context=newContext,
                    )

                    currentAltReachedAcceptState = self.closure(
                        input,
                        c,
                        configs,
                        currentAltReachedAcceptState,
                        speculative,
                        treatEofAsEpsilon,
                    )

        return currentAltReachedAcceptState

    # optimization
    if not config.state.epsilonOnlyTransitions:
        if not currentAltReachedAcceptState or not config.passedThroughNonGreedyDecision:
            configs.add(config)

    for t in config.state.transitions:
        c = LexerATNSimulator__getEpsilonTarget(
            self,
            input,
            config,
            t,
            configs,
            speculative,
            treatEofAsEpsilon,
        )

        if c is not None:
            currentAltReachedAcceptState = self.closure(
                input,
                c,
                configs,
                currentAltReachedAcceptState,
                speculative,
                treatEofAsEpsilon,
            )

    return currentAltReachedAcceptState


# side-effect: can alter configs.hasSemanticContext
# LexerATNConfig
cpdef object LexerATNSimulator__getEpsilonTarget(
        self: LexerATNSimulator,
        input: InputStream,
        config: LexerATNConfig,
        t: Transition,
        configs: ATNConfigSet,
        speculative: bool,
        treatEofAsEpsilon: bool
):
    c = None
    if t.serializationType == Transition.RULE:
        newContext = SingletonPredictionContext.create(config.context, t.followState.stateNumber)

        c = LexerATNConfig(
            state=t.target,
            config=config,
            context=newContext,
        )

    elif t.serializationType == Transition.PRECEDENCE:
        raise UnsupportedOperationException("Precedence predicates are not supported in lexers.")

    elif t.serializationType == Transition.PREDICATE:
        #  Track traversing semantic predicates. If we traverse,
        # we cannot add a DFA state for this "reach" computation
        # because the DFA would not test the predicate again in the
        # future. Rather than creating collections of semantic predicates
        # like v3 and testing them on prediction, v4 will test them on the
        # fly all the time using the ATN not the DFA. This is slower but
        # semantically it's not used that often. One of the key elements to
        # this predicate mechanism is not adding DFA states that see
        # predicates immediately afterwards in the ATN. For example,

        # a : ID {p1}? | ID {p2}? ;

        # should create the start state for rule 'a' (to save start state
        # competition), but should not create target of ID state. The
        # collection of ATN states the following ID references includes
        # states reached by traversing predicates. Since this is when we
        # test them, we cannot cash the DFA state target of ID.

        if LexerATNSimulator.debug:
            print("EVAL rule " + str(t.ruleIndex) + ":" + str(t.predIndex))
        configs.hasSemanticContext = True
        if self.evaluatePredicate(input, t.ruleIndex, t.predIndex, speculative):
            c = LexerATNConfig(state=t.target, config=config)

    elif t.serializationType == Transition.ACTION:
        if config.context is None or config.context.hasEmptyPath():
            # execute actions anywhere in the start rule for a token.
            #
            # TODO: if the entry rule is invoked recursively, some
            # actions may be executed during the recursive call. The
            # problem can appear when hasEmptyPath() is true but
            # isEmpty() is false. In this case, the config needs to be
            # split into two contexts - one with just the empty path
            # and another with everything but the empty path.
            # Unfortunately, the current algorithm does not allow
            # getEpsilonTarget to return two configurations, so
            # additional modifications are needed before we can support
            # the split operation.
            lexerActionExecutor = LexerActionExecutor.append(
                config.lexerActionExecutor,
                self.atn.lexerActions[t.actionIndex],
            )

            c = LexerATNConfig(
                state=t.target,
                config=config,
                lexerActionExecutor=lexerActionExecutor,
            )

        else:
            # ignore actions in referenced rules
            c = LexerATNConfig(state=t.target, config=config)

    elif t.serializationType == Transition.EPSILON:
        c = LexerATNConfig(state=t.target, config=config)

    elif t.serializationType in [Transition.ATOM, Transition.RANGE, Transition.SET]:
        if treatEofAsEpsilon:
            if t.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE):
                c = LexerATNConfig(state=t.target, config=config)

    return c


cdef class CyATNConfig:

    def __init__(
            self,
            state: ATNState = None,
            alt: int = None,
            context: PredictionContext = None,
            semantic: SemanticContext = None,
            config: ATNConfig = None,
    ):
        if config is not None:
            if state is None:
                state = config.state
            if alt is None:
                alt = config.alt
            if context is None:
                context = config.context
            if semantic is None:
                semantic = config.semanticContext

        if semantic is None:
            semantic = SemanticContext.NONE

        # The ATN state associated with this configuration#/
        self.state = state

        # What alt (or lexer rule) is predicted by this configuration#/
        self.alt = alt

        # The stack of invoking states leading to the rule/states associated with this config.  We track only those
        # contexts pushed during execution of the ATN simulator.
        self.context = context
        self.semanticContext = semantic

        # We cannot execute predicates dependent upon local context unless we know for sure we are in the correct
        # context. Because there is no way to do this efficiently, we simply cannot evaluate dependent predicates unless
        # we are in the rule that initially invokes the ATN simulator.

        # closure() tracks the depth of how far we dip into the outer context: depth > 0. Note that it may not be
        # totally accurate depth since I don't ever decrement. TODO: make it a boolean then
        self.reachesIntoOuterContext = 0 if config is None else config.reachesIntoOuterContext
        self.precedenceFilterSuppressed = False if config is None else config.precedenceFilterSuppressed

    # An ATN configuration is equal to another if both have the same state, they predict the same alternative, and
    # syntactic/semantic contexts are the same.
    def __eq__(self, other):
        if self is other:
            return True
        elif not isinstance(other, ATNConfig):
            return False
        else:
            return (
                    self.state.stateNumber == other.state.stateNumber and
                    self.alt == other.alt and
                    ((self.context is other.context) or (self.context == other.context)) and
                    self.semanticContext == other.semanticContext and
                    self.precedenceFilterSuppressed == other.precedenceFilterSuppressed
            )

    def __hash__(self):
        return hash((self.state.stateNumber, self.alt, self.context, self.semanticContext))

    cpdef hashCodeForConfigSet(self):
        return hash((self.state.stateNumber, self.alt, hash(self.semanticContext)))

    cpdef equalsForConfigSet(self, other):
        if self is other:
            return True
        elif not isinstance(other, ATNConfig):
            return False
        else:
            return (
                    self.state.stateNumber == other.state.stateNumber and
                    self.alt == other.alt and
                    self.semanticContext == other.semanticContext
            )

    def __str__(self):
        with io.StringIO() as buf:
            buf.write('(')
            buf.write(str(self.state))
            buf.write(",")
            buf.write(str(self.alt))
            if self.context is not None:
                buf.write(",[")
                buf.write(str(self.context))
                buf.write("]")
            if self.semanticContext is not None and self.semanticContext is not SemanticContext.NONE:
                buf.write(",")
                buf.write(str(self.semanticContext))
            if self.reachesIntoOuterContext > 0:
                buf.write(",up=")
                buf.write(str(self.reachesIntoOuterContext))
            buf.write(')')
            return buf.getvalue()


cdef class CyLexerATNConfig(CyATNConfig):

    def __init__(
            self,
            state: ATNState,
            alt: int = None,
            context: PredictionContext = None,
            semantic: SemanticContext = SemanticContext.NONE,
            lexerActionExecutor: LexerActionExecutor = None,
            config: LexerATNConfig = None,
    ):
        super().__init__(state=state, alt=alt, context=context, semantic=semantic, config=config)

        if config is not None:
            if lexerActionExecutor is None:
                lexerActionExecutor = config.lexerActionExecutor

        # This is the backing field for {@link #getLexerActionExecutor}.
        self.lexerActionExecutor = lexerActionExecutor
        self.passedThroughNonGreedyDecision = False if config is None else self.checkNonGreedyDecision(config, state)

    def __hash__(self):
        return hash((
            self.state.stateNumber,
            self.alt,
            self.context,
            self.semanticContext,
            self.passedThroughNonGreedyDecision,
            self.lexerActionExecutor,
        ))

    def __eq__(self, other):
        if self is other:
            return True
        elif not isinstance(other, LexerATNConfig):
            return False
        if self.passedThroughNonGreedyDecision != other.passedThroughNonGreedyDecision:
            return False
        if not (self.lexerActionExecutor == other.lexerActionExecutor):
            return False
        return super().__eq__(other)

    cpdef hashCodeForConfigSet(self):
        return hash(self)

    cpdef equalsForConfigSet(self, other):
        return self == other

    cpdef checkNonGreedyDecision(self, source: LexerATNConfig, target: ATNState):
        return source.passedThroughNonGreedyDecision or isinstance(target, DecisionState) and target.nonGreedy
