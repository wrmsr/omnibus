"""  # noqa
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)

4440645/863938    5.173    0.000   24.374    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:317(closure)
  4993206    4.551    0.000   13.223    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:361(getEpsilonTarget)
  4440646    3.578    0.000    7.626    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:114(__init__)
10004289/3007740    2.878    0.000    5.898    0.000 {built-in method builtins.hash}
  4451670    2.615    0.000    2.615    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:25(__init__)
 14442146    1.596    0.000    1.596    0.000 {built-in method builtins.isinstance}
  1394624    1.310    0.000    2.503    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:62(__eq__)
  2790697    1.190    0.000    4.100    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:124(__hash__)
  1397105    1.150    0.000    5.438    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:71(add)
  1397105    1.016    0.000    4.135    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:96(getOrAdd)
  3608771    0.936    0.000    1.443    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:152(checkNonGreedyDecision)
  1393552    0.931    0.000    3.533    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:129(__eq__)
     8577    0.876    0.000   24.974    0.003 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:300(computeStartState)
  2803257    0.815    0.000    1.112    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/SemanticContext.py:108(__hash__)
1556284/569333    0.782    0.000    0.940    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:134(__eq__)
   790613    0.593    0.000    1.532    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:119(__init__)
   790612    0.367    0.000    1.899    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:111(create)
  1394771    0.324    0.000    2.944    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:142(hashCodeForConfigSet)
   790635    0.312    0.000    0.771    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:71(calculateHashCode)
    79143    0.307    0.000    3.850    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:132(__eq__)
  1399180    0.277    0.000    2.555    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:156(<lambda>)
  1777084    0.250    0.000    0.250    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:144(__hash__)
  1821081    0.244    0.000    0.244    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:169(__hash__)
    17090    0.225    0.000    2.780    0.000 {built-in method _functools.reduce}
    17163    0.198    0.000    0.321    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:522(<genexpr>)
  1462292    0.193    0.000    6.834    0.000 {method 'get' of 'dict' objects}
     8577    0.187    0.000   34.498    0.004 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:88(match)
   790624    0.168    0.000    0.168    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:52(__init__)
    78417    0.166    0.000    0.322    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:293(getReachableTarget)
  1522265    0.162    0.000    0.162    0.000 {method 'append' of 'list' objects}

        3    0.000    0.000   34.668   11.556 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/BufferedTokenStream.py:298(fill)
       13    0.013    0.001   34.668    2.667 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/BufferedTokenStream.py:119(fetch)
     7292    0.021    0.000   34.653    0.005 /Users/spinlock/src/wrmsr/omnibus/omnibus/asts/_antlr/Python3Lexer.py:765(nextToken)
     7292    0.041    0.000   34.620    0.005 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/Lexer.py:105(nextToken)
     8577    0.187    0.000   34.498    0.004 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:88(match)
     8577    0.022    0.000   34.305    0.004 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:111(matchATN)
     8577    0.876    0.000   24.974    0.003 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:300(computeStartState)
4440645/863938    5.173    0.000   24.374    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:317(closure)
  4993206    4.551    0.000   13.223    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:361(getEpsilonTarget)
  4440646    3.578    0.000    7.626    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:114(__init__)
    16785    0.051    0.000    7.053    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:519(addDFAState)
  1462292    0.193    0.000    6.834    0.000 {method 'get' of 'dict' objects}
10004289/3007740    2.878    0.000    5.898    0.000 {built-in method builtins.hash}
  1397105    1.150    0.000    5.438    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:71(add)
  1397105    1.016    0.000    4.135    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:96(getOrAdd)
  2790697    1.190    0.000    4.100    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:124(__hash__)
    87719    0.050    0.000    3.907    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/dfa/DFAState.py:100(__eq__)
    79143    0.307    0.000    3.850    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:132(__eq__)
  1393552    0.931    0.000    3.533    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:129(__eq__)
  1394771    0.324    0.000    2.944    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:142(hashCodeForConfigSet)
    17085    0.005    0.000    2.811    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/dfa/DFAState.py:86(__hash__)
    17085    0.009    0.000    2.799    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:148(__hash__)
    17085    0.010    0.000    2.790    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:155(hashConfigs)
    17090    0.225    0.000    2.780    0.000 {built-in method _functools.reduce}
     8576    0.127    0.000    2.717    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:133(execATN)
  4451670    2.615    0.000    2.615    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:25(__init__)
  1399180    0.277    0.000    2.555    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfigSet.py:156(<lambda>)
  1394624    1.310    0.000    2.503    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/ATNConfig.py:62(__eq__)
     8486    0.018    0.000    2.205    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:222(computeTargetState)
   790612    0.367    0.000    1.899    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:111(create)
     8486    0.092    0.000    1.696    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/atn/LexerATNSimulator.py:255(getReachableConfigSet)
 14442146    1.596    0.000    1.596    0.000 {built-in method builtins.isinstance}
   790613    0.593    0.000    1.532    0.000 /Users/spinlock/src/wrmsr/omnibus/omnibus/_vendor/antlr4/PredictionContext.py:119(__init__)
"""
from libcpp cimport bool

from functools import reduce
import io

from ..._vendor.antlr4 import InputStream
from ..._vendor.antlr4 import Lexer
from ..._vendor.antlr4 import LexerATNSimulator
from ..._vendor.antlr4 import Token
from ..._vendor.antlr4.atn.ATN import ATN
from ..._vendor.antlr4.atn.ATNConfig import ATNConfig
from ..._vendor.antlr4.atn.ATNConfig import LexerATNConfig
from ..._vendor.antlr4.atn.ATNConfigSet import ATNConfigSet
from ..._vendor.antlr4.atn.ATNConfigSet import OrderedATNConfigSet
from ..._vendor.antlr4.atn.ATNSimulator import ATNSimulator
from ..._vendor.antlr4.atn.ATNState import ATNState
from ..._vendor.antlr4.atn.ATNState import DecisionState
from ..._vendor.antlr4.atn.ATNState import RuleStopState
from ..._vendor.antlr4.atn.LexerActionExecutor import LexerActionExecutor
from ..._vendor.antlr4.atn.SemanticContext import SemanticContext
from ..._vendor.antlr4.atn.Transition import Transition
from ..._vendor.antlr4.error.Errors import IllegalStateException
from ..._vendor.antlr4.error.Errors import UnsupportedOperationException
from ..._vendor.antlr4.PredictionContext import merge
from ..._vendor.antlr4.PredictionContext import PredictionContext
from ..._vendor.antlr4.PredictionContext import SingletonPredictionContext
from ..._vendor.antlr4.Utils import str_list


# ATNConfigSet
cpdef object LexerATNSimulator__computeStartState(
        self: LexerATNSimulator,
        input: InputStream,
        p: ATNState,
):
    initialContext = PredictionContext.EMPTY
    configs = OrderedATNConfigSet()
    for i in range(0, len(p.transitions)):
        target = p.transitions[i].target
        c = LexerATNConfig(state=target, alt=i + 1, context=initialContext)
        LexerATNSimulator__closure(self, input, c, configs, False, False, False)
    return configs


cpdef bool LexerATNSimulator__closure(
        self: LexerATNSimulator,
        input: InputStream,
        config: LexerATNConfig,
        configs: ATNConfigSet,
        currentAltReachedAcceptState: bool,
        speculative: bool,
        treatEofAsEpsilon: bool
):
    if isinstance(config.state, RuleStopState):
        if config.context is None or config.context.hasEmptyPath():
            if config.context is None or config.context.isEmpty():
                configs.add(config)
                return True

            else:
                configs.add(LexerATNConfig(
                    state=config.state,
                    config=config,
                    context=PredictionContext.EMPTY,
                ))
                currentAltReachedAcceptState = True

        if config.context is not None and not config.context.isEmpty():
            for i in range(0, len(config.context)):
                if config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE:
                    newContext = config.context.getParent(i)  # "pop" return state
                    returnState = self.atn.states[config.context.getReturnState(i)]

                    c = LexerATNConfig(
                        state=returnState,
                        config=config,
                        context=newContext,
                    )

                    currentAltReachedAcceptState = self.closure(
                        input,
                        c,
                        configs,
                        currentAltReachedAcceptState,
                        speculative,
                        treatEofAsEpsilon,
                    )

        return currentAltReachedAcceptState

    # optimization
    if not config.state.epsilonOnlyTransitions:
        if not currentAltReachedAcceptState or not config.passedThroughNonGreedyDecision:
            configs.add(config)

    for t in config.state.transitions:
        c = LexerATNSimulator__getEpsilonTarget(
            self,
            input,
            config,
            t,
            configs,
            speculative,
            treatEofAsEpsilon,
        )

        if c is not None:
            currentAltReachedAcceptState = self.closure(
                input,
                c,
                configs,
                currentAltReachedAcceptState,
                speculative,
                treatEofAsEpsilon,
            )

    return currentAltReachedAcceptState


cpdef object LexerATNSimulator__getEpsilonTarget(
        self: LexerATNSimulator,
        input: InputStream,
        config: LexerATNConfig,
        t: Transition,
        configs: ATNConfigSet,
        speculative: bool,
        treatEofAsEpsilon: bool
):
    c = None
    if t.serializationType == Transition.RULE:
        newContext = SingletonPredictionContext.create(config.context, t.followState.stateNumber)

        c = LexerATNConfig(
            state=t.target,
            config=config,
            context=newContext,
        )

    elif t.serializationType == Transition.PRECEDENCE:
        raise UnsupportedOperationException("Precedence predicates are not supported in lexers.")

    elif t.serializationType == Transition.PREDICATE:
        configs.hasSemanticContext = True
        if self.evaluatePredicate(input, t.ruleIndex, t.predIndex, speculative):
            c = LexerATNConfig(state=t.target, config=config)

    elif t.serializationType == Transition.ACTION:
        if config.context is None or config.context.hasEmptyPath():
            lexerActionExecutor = LexerActionExecutor.append(
                config.lexerActionExecutor,
                self.atn.lexerActions[t.actionIndex],
            )

            c = LexerATNConfig(
                state=t.target,
                config=config,
                lexerActionExecutor=lexerActionExecutor,
            )

        else:
            # ignore actions in referenced rules
            c = LexerATNConfig(state=t.target, config=config)

    elif t.serializationType == Transition.EPSILON:
        c = LexerATNConfig(state=t.target, config=config)

    elif t.serializationType in [Transition.ATOM, Transition.RANGE, Transition.SET]:
        if treatEofAsEpsilon:
            if t.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE):
                c = LexerATNConfig(state=t.target, config=config)

    return c


cdef class CyATNConfig:

    def __init__(
            self,
            state: ATNState = None,
            alt: int = None,
            context: PredictionContext = None,
            semantic: SemanticContext = None,
            config: ATNConfig = None,
    ):
        if config is not None:
            if state is None:
                state = config.state
            if alt is None:
                alt = config.alt
            if context is None:
                context = config.context
            if semantic is None:
                semantic = config.semanticContext

        if semantic is None:
            semantic = SemanticContext.NONE

        self.state = state

        self.alt = alt

        self.context = context
        self.semanticContext = semantic

        self.reachesIntoOuterContext = 0 if config is None else config.reachesIntoOuterContext
        self.precedenceFilterSuppressed = False if config is None else config.precedenceFilterSuppressed

    def __eq__(self, other):
        if self is other:
            return True
        elif not isinstance(other, ATNConfig):
            return False
        else:
            return (
                    self.state.stateNumber == other.state.stateNumber and
                    self.alt == other.alt and
                    ((self.context is other.context) or (self.context == other.context)) and
                    self.semanticContext == other.semanticContext and
                    self.precedenceFilterSuppressed == other.precedenceFilterSuppressed
            )

    def __hash__(self):
        return hash((self.state.stateNumber, self.alt, self.context, self.semanticContext))

    cpdef hashCodeForConfigSet(self):
        return hash((self.state.stateNumber, self.alt, hash(self.semanticContext)))

    cpdef equalsForConfigSet(self, other):
        if self is other:
            return True
        elif not isinstance(other, ATNConfig):
            return False
        else:
            return (
                    self.state.stateNumber == other.state.stateNumber and
                    self.alt == other.alt and
                    self.semanticContext == other.semanticContext
            )

    def __str__(self):
        with io.StringIO() as buf:
            buf.write('(')
            buf.write(str(self.state))
            buf.write(",")
            buf.write(str(self.alt))
            if self.context is not None:
                buf.write(",[")
                buf.write(str(self.context))
                buf.write("]")
            if self.semanticContext is not None and self.semanticContext is not SemanticContext.NONE:
                buf.write(",")
                buf.write(str(self.semanticContext))
            if self.reachesIntoOuterContext > 0:
                buf.write(",up=")
                buf.write(str(self.reachesIntoOuterContext))
            buf.write(')')
            return buf.getvalue()


cdef class CyLexerATNConfig(CyATNConfig):

    def __init__(
            self,
            state: ATNState,
            alt: int = None,
            context: PredictionContext = None,
            semantic: SemanticContext = SemanticContext.NONE,
            lexerActionExecutor: LexerActionExecutor = None,
            config: LexerATNConfig = None,
    ):
        super().__init__(state=state, alt=alt, context=context, semantic=semantic, config=config)

        if config is not None:
            if lexerActionExecutor is None:
                lexerActionExecutor = config.lexerActionExecutor

        # This is the backing field for {@link #getLexerActionExecutor}.
        self.lexerActionExecutor = lexerActionExecutor
        self.passedThroughNonGreedyDecision = False if config is None else self.checkNonGreedyDecision(config, state)

    def __hash__(self):
        return hash((
            self.state.stateNumber,
            self.alt,
            self.context,
            self.semanticContext,
            self.passedThroughNonGreedyDecision,
            self.lexerActionExecutor,
        ))

    def __eq__(self, other):
        if self is other:
            return True
        elif not isinstance(other, LexerATNConfig):
            return False
        if self.passedThroughNonGreedyDecision != other.passedThroughNonGreedyDecision:
            return False
        if not (self.lexerActionExecutor == other.lexerActionExecutor):
            return False
        return super().__eq__(other)

    cpdef hashCodeForConfigSet(self):
        return hash(self)

    cpdef equalsForConfigSet(self, other):
        return self == other

    cpdef checkNonGreedyDecision(self, source: LexerATNConfig, target: ATNState):
        return source.passedThroughNonGreedyDecision or isinstance(target, DecisionState) and target.nonGreedy


cdef class CyATNConfigSet:

    def __init__(self, fullCtx: bool = True):
        self.configLookup = dict()
        self.fullCtx = fullCtx
        self.readonly = False
        self.configs = []

        self.uniqueAlt = 0
        self.conflictingAlts = None

        self.hasSemanticContext = False
        self.dipsIntoOuterContext = False

        self.cachedHashCode = -1

    def __iter__(self):
        return self.configs.__iter__()

    def add(self, config: ATNConfig, mergeCache=None):
        if self.readonly:
            raise Exception("This set is readonly")

        if config.semanticContext is not SemanticContext.NONE:
            self.hasSemanticContext = True

        if config.reachesIntoOuterContext > 0:
            self.dipsIntoOuterContext = True

        existing = self.getOrAdd(config)
        if existing is config:
            self.cachedHashCode = -1
            self.configs.append(config)
            return True

        rootIsWildcard = not self.fullCtx
        merged = merge(existing.context, config.context, rootIsWildcard, mergeCache)

        existing.reachesIntoOuterContext = max(existing.reachesIntoOuterContext, config.reachesIntoOuterContext)

        if config.precedenceFilterSuppressed:
            existing.precedenceFilterSuppressed = True

        existing.context = merged

        return True

    def getOrAdd(self, config: ATNConfig):
        h = config.hashCodeForConfigSet()
        l = self.configLookup.get(h, None)
        if l is not None:
            r = next((cfg for cfg in l if config.equalsForConfigSet(cfg)), None)
            if r is not None:
                return r
        if l is None:
            l = [config]
            self.configLookup[h] = l
        else:
            l.append(config)
        return config

    def getStates(self):
        return set(c.state for c in self.configs)

    def getPredicates(self):
        return list(cfg.semanticContext for cfg in self.configs if cfg.semanticContext != SemanticContext.NONE)

    def get(self, i: int):
        return self.configs[i]

    def optimizeConfigs(self, interpreter: ATNSimulator):
        if self.readonly:
            raise IllegalStateException("This set is readonly")
        if len(self.configs) == 0:
            return
        for config in self.configs:
            config.context = interpreter.getCachedContext(config.context)

    def addAll(self, coll: list):
        for c in coll:
            self.add(c)
        return False

    def __eq__(self, other):
        if self is other:
            return True
        elif not isinstance(other, ATNConfigSet):
            return False

        same = (
                self.configs is not None and
                self.configs == other.configs and
                self.fullCtx == other.fullCtx and
                self.uniqueAlt == other.uniqueAlt and
                self.conflictingAlts == other.conflictingAlts and
                self.hasSemanticContext == other.hasSemanticContext and
                self.dipsIntoOuterContext == other.dipsIntoOuterContext
        )

        return same

    def __hash__(self):
        if self.readonly:
            if self.cachedHashCode == -1:
                self.cachedHashCode = self.hashConfigs()
            return self.cachedHashCode
        return self.hashConfigs()

    def hashConfigs(self):
        return reduce(lambda h, cfg: hash((h, cfg)), self.configs, 0)

    def __len__(self):
        return len(self.configs)

    def isEmpty(self):
        return len(self.configs) == 0

    def __contains__(self, config):
        if self.configLookup is None:
            raise UnsupportedOperationException("This method is not implemented for readonly sets.")
        h = config.hashCodeForConfigSet()
        l = self.configLookup.get(h, None)
        if l is not None:
            for c in l:
                if config.equalsForConfigSet(c):
                    return True
        return False

    def clear(self):
        if self.readonly:
            raise IllegalStateException("This set is readonly")
        self.configs.clear()
        self.cachedHashCode = -1
        self.configLookup.clear()

    def setReadonly(self, readonly: bool):
        self.readonly = readonly
        self.configLookup = None  # can't mod, no need for lookup cache

    def __str__(self):
        with io.StringIO() as buf:
            buf.write(str_list(self.configs))
            if self.hasSemanticContext:
                buf.write(",hasSemanticContext=")
                buf.write(str(self.hasSemanticContext))
            if self.uniqueAlt != ATN.INVALID_ALT_NUMBER:
                buf.write(",uniqueAlt=")
                buf.write(str(self.uniqueAlt))
            if self.conflictingAlts is not None:
                buf.write(",conflictingAlts=")
                buf.write(str(self.conflictingAlts))
            if self.dipsIntoOuterContext:
                buf.write(",dipsIntoOuterContext")
            return buf.getvalue()


cdef class CyOrderedATNConfigSet(CyATNConfigSet):

    def __init__(self):
        super().__init__()
